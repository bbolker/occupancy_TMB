---
title: "Fitting simple occupancy models in TMB etc."
author: "B. Bolker"
date: '`r Sys.time()`'
output:
  html_document: default
---

# To do

- pull in .cpp/stan/jags from files, display/highlight

# Overview

This is cut down from Olivier Gimenez's dynamic-occupancy equivalent, for my own educational purposes.

Simulate some data (366 sites, 40 samples/site), model using TMB, ADMB, JAGS and Unmarked and finally perform a quick benchmarking. See Olivier's [previous post](https://oliviergimenez.github.io/post/occupancy_in_admb/) (on dynamic occupancy models: here we're cutting it down to simple models).

```{r pkgs, message=FALSE, warning=FALSE}
library(tidyverse)
library(unmarked)
library(TMB)
```

```{r simulate, message=FALSE, warning=FALSE}
R <- 366 # number of sites
J <- 40  # samples per site
beta_p <- c(-1,1) # fixed effect parameters for detection
beta_psi <- c(-1,1) # fixed effect parameters for occupancy

set.seed(101)
dd <- expand.grid(site=factor(1:R), sample=factor(1:J))
x_occ_0 <- rnorm(R)
occ_prob <- plogis(model.matrix(~x_occ_0) %*% beta_psi)
occ_val <- rbinom(R, size=1, prob=occ_prob)
dd <- dd %>%
  mutate(x_p = rnorm(R*J),      ## detection covariate
         x_psi = x_occ_0[site], ## occupancy covariate
         occ = occ_val[site],   ## map occupancy to samples
         det_prob = plogis(model.matrix(~x_p) %*% beta_p)*occ,
         obs =rbinom(R*J, size=1, prob=det_prob)
         )
```

Back-calculate capture histories and site info for `unmarked::occu`:

```{r unmarked_extract}
## basic site-level info
siteCovs_0 <- (dd
  %>% select(site,x_psi)
  %>% unique()
)
## unmarked::occu() wants it "naked"; no tibbles
siteCovs <- (siteCovs_0
  %>% select(-site)
  %>% as.data.frame()
)
obsCovs <- (dd
  %>% arrange(site) ## need site-major order!
  %>% select(x_p)
  %>% as.data.frame()
)
y <- (dd
  %>% select(site,sample,obs)
  %>% spread(sample,obs)
  %>% select(-site)
  %>% as.matrix()
)
```

```{r unmarked_run}
uf <- unmarkedFrameOccu(y, siteCovs=siteCovs, obsCovs=obsCovs)
occu( ~ x_p ~ x_psi, data=uf)
```

For most of the other approaches it will be convenient to construct the model matrices ourselves in R, before them passing them to the relevant toolbox.

```{r make_model_matrices}
site_tot <- dd %>% group_by(site) %>% summarise(x=sum(obs)) %>% pull(x)
X_psi <- model.matrix(~ x_psi, data=siteCovs_0)
X_p <- model.matrix(~ x_p, data=dd)
```

## TMB

```{r tmb_setup}
compile("simple_occupancy.cpp")
dyn.load(dynlib("simple_occupancy"))
f <- MakeADFun(
  data = c(as.list(dd[c("obs","site")]),
           list(Xpsi = X_psi,
                Xp = X_p,
                site_tot = site_tot)),
  parameters = list(beta_psi = rep(0,ncol(X_psi)),
                    beta_p = rep(0,ncol(X_p))),
  DLL = "simple_occupancy")
do.call("optim",f)
```

## brain dump

- formatting options for hierarchical input: capture-history matrix (convenient esp for balanced obs) vs. vector + site indicator (easier when everything is long format)? separate site-level model matrix etc. or combined (inefficient but maybe convenient) site + sample model matrix? Or a list? (The matrix/list minimize indexing to site level ... could provide an index vector ... In any case, need to maintain key distinction that occupancy is modeled at the site level ...)

